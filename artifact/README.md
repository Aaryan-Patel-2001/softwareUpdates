# Argosy: Verifying layered storage systems with recovery refinement

## Kicking the tires

You'll need Coq (we regularly test with v8.8.2, v8.9, and master) to compile the proofs.

You'll need Haskell stack to build and run the logging example.

If you want to compile from the repo, you can clone it from
[github.com/mit-pdos/argosy](https://github.com/mit-pdos/argosy). The main
difference is that you'll also need to download the dependencies with `git
submodule update --init --recursive`.

Running `make -j2` will compile the proofs and print two things: the type of the
main correctness theorem, applied to the composed logging and replication
system, and a list of assumptions. These assumptions are:

- `eq_rect_eq`, a standard assumption about dependent equality.
- The three axioms `bytes`, `bytes0`, and `bytes_dec`, which form a model of
  byte sequences and are instantiated with Haskell's `Data.ByteString` in the
  extracted code.
- `Impl.LogHdr_fmt` and `Impl.Descriptor_fmt`, axiomatic code to encode the
  logging data structures.

To compile the logging code, run its unit tests, and see a demo of using
logging-client, run:

```
make extract
cd logging-client
stack test
./demo.sh
```

Note that running `stack` and `demo.sh` requires your working directory to be
`logging-client`.

## Source code overview

The [src](src/) subdirectory contains the Coq development. Within that directory:

* The folder [Helpers](src/Helpers) contains various useful libraries:

    * [Disk.v](src/Helpers/Disk.v) -- a model of disks as lists of blocks.
      Blocks themselves are treated as an abstract type, with a few properties
      axiomatized -- during extraction, they are mapped to Haskell ByteStrings.

    * [RelationAlgebra.v](src/Helpers/RelationAlgebra.v) -- defines relational
      combinators and proves their basic properties.

    * [RelationRewriting.v](src/Helpers/RelationRewriting.v) -- provides tactics
      to normalize and rewrite by equational/inequational laws for relations.

* The folder [Spec](src/Spec) contains files for the semantics of programs and
  reasoning about them.

    * [Proc.v](src/Spec/Proc.v) -- definition of the syntax and semantics of
      programs as free monads generated by set of basic operations.

    * [Layer.v](src/Spec/Layer.v) -- defines layers, which define an "API" as a
      bundle of operations and a form of state. Also describes how to implement a
      layer in terms of another, compilation between layers, and the notion of
      layer refinement (which we also call "recovery refinement"). The theorem
      `compile_exec_seq_ok` proves that layer refinements preserve the semantics
      of complete interactions. `refinement_transitive` composes two
      implementations and shows the composition is also a recovery refinement.

    * [Hoare.v](src/Spec/Hoare.v) -- our embedding of Crash Hoare Logic (CHL),
      which we use to help prove that an implementation is a layer refinement.

* The folder [Examples](src/Examples) contains examples of using the framework to prove
  recovery refinement.

    * [ReplicatedDisk](src/Examples/ReplicatedDisk) -- contains an example
      proving that a disk replication implementation is a recovery refinement
      from a layer with a single robust disk, into a layer with two faulty
      disks. [OneDiskAPI.v](src/Examples/ReplicatedDisk/OneDiskAPI.v) and
      [TwoDiskAPI.v](src/Examples/ReplicatedDisk/TwoDiskAPI.v) define the source
      and target layers, while
      [ReplicatedDiskImpl.v](src/Examples/ReplicatedDisk/ReplicatedDiskImpl.v)
      is the implementation and proof that it is a refinement.

    * [Logging](src/Examples/Logging) -- contains an example proving that a
      write-ahead logging implementation is a recovery refinement from a
      transactional disk layer into a layer with one disk.

        * [TxnDiskAPI.v](src/Examples/Logging/TxnDiskAPI.v) defines the
          transactional layer.

        * [Impl.v](src/Examples/Logging/Impl.v) is the
          write-ahead logging code.

        * [HoareProof.v](src/Examples/Logging/Impl.v) is
          the proof of recovery refinement.

        * [ComposedRefinement.v](src/Examples/Logging/ComposedRefinement.v)
          composes the refinement proof with the replicated disk example to
          obtain a refinement from the transactional disk to the two disks.

The [vendor](vendor/) subdirectory contains various submodules for Coq libraries
that we use in the development. See the README files within each submodule for
documentation.

The [logging-client](logging-client/) subdirectory contains code to extract and
run the composed logging and replication implementation, which provides a
transactional API on top of two unreliable disks. See its separate
[README.md](logging-client/README.md) for details.
